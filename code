import time
import math
import csv
from collections import namedtuple
import Adafruit_ADS1x15

PhaseMetrics = namedtuple("PhaseMetrics", ["Vrms", "Irms", "P", "S", "PF"])

# --------------------------- CONFIGURAZIONE ---------------------------
ADS1_ADDR = 0x48
ADS2_ADDR = 0x49
GAIN = 1
RELAY_PINS = [17, 27, 22]
RELAY_ACTIVE_HIGH = True
SAMPLES = 400
LOWER_PF = 0.95
UPPER_PF = 0.99
MIN_TIME_BETWEEN_STEPS = 2.5
SETTLING_TIME_AFTER_STEP = 1.0 
FS_VOLTAGE_BY_GAIN = {
    2/3: 6.144, 1: 4.096, 2: 2.048, 4: 1.024, 8: 0.512, 16: 0.256
}
FS_VOLT = FS_VOLTAGE_BY_GAIN.get(GAIN, 4.096)
ADC_MAX_COUNT = 32768.0
V_PER_COUNT = FS_VOLT / ADC_MAX_COUNT
VREF = 3.3 / 2.0
BURDEN_RESISTANCE = 20.0
# ---------------------------------------------------------------------

class PowerFactorController:
    def __init__(self):
        # Lazy import di RPi.GPIO (essenziale per l'ambiente di test)
        import RPi.GPIO as GPIO 
        
        self.adc1 = Adafruit_ADS1x15.ADS1115(address=ADS1_ADDR)
        self.adc2 = Adafruit_ADS1x15.ADS1115(address=ADS2_ADDR)
        
        GPIO.setmode(GPIO.BCM)
        for p in RELAY_PINS:
            GPIO.setup(p, GPIO.OUT)
            self._set_relay_state(p, False) 

        self.steps = 0
        self.max_steps = len(RELAY_PINS)
        self.last_step_time = 0.0

    def _set_relay_state(self, pin, state_on):
        import RPi.GPIO as GPIO 
        output = GPIO.HIGH if (state_on == RELAY_ACTIVE_HIGH) else GPIO.LOW
        GPIO.output(pin, output)

    def cleanup(self):
        import RPi.GPIO as GPIO 
        GPIO.cleanup()
        
    def compute_phase_metrics(self, v_array, i_array):
        """Calcola metriche di fase da vettori campione."""
        N = len(v_array)
        if N == 0:
            return PhaseMetrics(0, 0, 0, 0, 0)

        v_mean = sum(v_array) / N
        i_mean = sum(i_array) / N
        v_ac = [x - v_mean for x in v_array]
        i_ac = [x - i_mean for x in i_array]

        v_rms = math.sqrt(sum(x*x for x in v_ac) / N)
        i_rms = math.sqrt(sum(x*x for x in i_ac) / N)
        p = sum(v*i for v,i in zip(v_ac, i_ac)) / N
        s = v_rms * i_rms
        pf = p / s if s != 0 else 0.0
        
        return PhaseMetrics(v_rms, i_rms, p, s, pf)

    def update_bank(self, pf_total):
        """Logica di controllo con isteresi e debounce."""
        now = time.time()
        action_desc = "Nessuna azione"

        # ðŸ’¡ CORREZIONE LOGICA: Settling Time (1.0s) deve venire prima del Debounce (2.5s)
        if now - self.last_step_time < SETTLING_TIME_AFTER_STEP:
               action_desc = "Hold (settling)"
               return action_desc
               
        # 1. Debounce (Hold)
        if now - self.last_step_time < MIN_TIME_BETWEEN_STEPS:
            action_desc = "Hold (debounce)"
            return action_desc


        if pf_total < LOWER_PF and self.steps < self.max_steps:
            pin = RELAY_PINS[self.steps]
            self._set_relay_state(pin, True)
            self.steps += 1
            self.last_step_time = now
            action_desc = f"Inserito step {self.steps}"

        elif pf_total > UPPER_PF and self.steps > 0:
            self.steps -= 1
            pin = RELAY_PINS[self.steps]
            self._set_relay_state(pin, False)
            self.last_step_time = now
            action_desc = f"Rimosso step {self.steps+1}"
            
        return action_desc
        
    def measure_window(self): return [[] for _ in range(3)], [[] for _ in range(3)], 0.0 
    def init_csv(self): pass
    def log_row(self, data): pass
    def run(self): pass
